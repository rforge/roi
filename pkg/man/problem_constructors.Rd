\name{LP}
\alias{LP}
\alias{QCP}
\alias{QP}
\alias{NLP}
\alias{MILP}
\alias{MIQCP}
\alias{MIQP}
\alias{MINLP}
\title{Problem Constructors and Methods}
\description{
  Constructors for ROI (optimization) problem objects based on problem class.
}
\usage{
LP   ( objective, constraints, bounds = NULL, maximum = FALSE )
QCP  ( objective, constraints, bounds = NULL, maximum = FALSE )
QP   ( objective, constraints, bounds = NULL, maximum = FALSE )
NLP  ( objective, constraints, bounds = NULL, maximum = FALSE )
MILP ( objective, constraints, bounds = NULL, types = NULL, maximum =
FALSE )
MIQCP( objective, constraints, bounds = NULL, types = NULL, maximum =
FALSE )
MIQP ( objective, constraints, bounds = NULL, types = NULL, maximum =
FALSE )
MINLP( objective, constraints, bounds = NULL, types = NULL, maximum =
FALSE )

\method{print}{LP}(x, ...)
}
\arguments{
  \item{objective}{an \code{\link{objective}} object for the specific
    problem constructor defining the objective function of the
    optimization problem. See \bold{Details} for more information.}
  \item{constraints}{a \code{\link{constraints}} object defining the
    constraints of the optimization problem. See \bold{Details} for more
    information.}
  \item{bounds}{\code{NULL} (default) or a list defining the (objective)
    variable bounds. The list is typically generated by the
    \code{\link{V_bound}} constructor. By default, each variable is
    bounded between \code{0} and \code{Inf}.}
  \item{types}{a vector indicating the (objective) variable
    types. \code{types} can be either \code{\dQuote{B}} (short for binary),
    \code{\dQuote{I}} (integer), or \code{\dQuote{C}}
    (continuous). Single values will be repeated to create a 
    vector to fit the corresponding problem object size. By default all
    variables are of type \code{\dQuote{C}}.}
  \item{maximum}{a logical specifying the direction of
    optimization. \code{FALSE} (default) means minimization of the
    objective variable and \code{TRUE} maximization.}
  \item{\dots}{optional arguments to the \code{print} method.}
}
\value{
  Depending on the problem constructor used the function returns an
  object of class \code{LP}, \code{QCP}, \code{QP}, \code{NLP},
  \code{MILP}, \code{MIQCP}, \code{MIQP}, or \code{MINLP}. 
}
\details{
  Problem constructors create \R objects, more specifically ROI objects,
  containing information about the optimization problem.

  The constructed problem object inherits from a specific problem
  class. Basically, it consists of a function to be optimized (the
  \code{objective}), possibly several \code{constraints}, variable
  \code{bounds}, variable \code{types} and the direction of optimization
  (\code{maximum}). Internally, these are the elements of an \R list.
  \describe{
    \item{\code{objective}}{Depending on the structure of the objective
      function a specific constructor function is to be used. E.g., if a
      linear function is to be optimized one uses the
      \code{\link{L_objective}} function, for quadratic function one uses
      the \code{\link{Q_objective}} function, and for other (i.e.,
      nonlinear) functions one uses the \code{F_objective} constructor.
    }
    \item{\code{constraints}}{Depending on the structure of the
      constraints a specific constructor function is to be used. E.g.,
      if an optimization problem is to be optimized subject to linear
      constraints one uses the \code{\link{L_constraint}} function, for
      quadratic constraints one uses the \code{\link{Q_constraint}}
      function, and for other (i.e., nonlinear) constraints one uses the
      \code{F_constraint} constructor.} 
    \item{\code{bounds}}{see above.} 
    \item{\code{types}}{see above.}
    \item{\code{maximum}}{see above.}
  }
}
\examples{
## Simple linear program.
## maximize:   2 x_1 + 4 x_2 + 3 x_3
## subject to: 3 x_1 + 4 x_2 + 2 x_3 <= 60
##             2 x_1 +   x_2 +   x_3 <= 40
##               x_1 + 3 x_2 + 2 x_3 <= 80
##               x_1, x_2, x_3 are non-negative real numbers

obj <- L_objective( c(2,4,3) )
constr <- L_constraint( L_constraint(matrix(c(3, 2, 1, 4, 1, 3, 2, 2, 2),
nrow = 3), dir = c("<=", "<=", "<="), rhs = c(60, 40, 80) )

lp <- LP( obj, constr, maximum = TRUE ) 
lp

## Simple mixed integer linear program.
## maximize:    3 x_1 + 1 x_2 + 3 x_3
## subject to: -1 x_1 + 2 x_2 +   x_3 <= 4
##                      4 x_2 - 3 x_3 <= 2
##                x_1 - 3 x_2 + 2 x_3 <= 3
##                x_1, x_3 are non-negative integers
##                x_2 is a non-negative real number

obj <- L_objective( c(3, 1, 3) )
constr <- L_constraint( matrix(c(-1, 0, 1, 2, 4, -3, 1, -3, 2), nrow =
3), dir = c("<=", "<=", "<="), rhs = c(4, 2, 3) )

milp <- MILP(obj, constr, types = c("I", "C", "I"), maximum = TRUE)
milp
     
## Same as above but with bounds replaced by
## -Inf <  x_1 <= 4
##    0 <= x_2 <= 100
##    2 <= x_3 <  Inf
     
bounds <- V_bound( li = c(1L, 3L), lb = c(-Inf, 2), ui = c(1L, 2L), ub
= c(4, 100) )

milp <- MILP( obj, constr, bounds = bounds, types = c("I", "C", "I"),
maximum = TRUE ) 

## Simple quadratic program:
## minimize: -(0 5 0) %*% x + 1/2 x^T x
## subject to:  A^T x >= rhs
## with rhs = (-8,2,0)^T
## and      (-4  2  0) 
##      A = (-3  1 -2)
##          ( 0  0  1)

obj <- Q_objective( L = c(0, 5, 0), Q = diag(1, 3) )
constr <- L_constraint( matrix(c(-4,-3,0,2,1,0,0,-2,1), ncol = 3), dir =
rep(">=", 3), rhs = c(-8,2,0))

qp <- QP( obj, constr )
     Dmat       <- matrix(0,3,3)
     diag(Dmat) <- 1
     dvec       <- c(0,5,0)
     Amat       <- matrix(c(-4,-3,0,2,1,0,0,-2,1),3,3)
     bvec       <- 
     solve.QP(Dmat,dvec,Amat,bvec=bvec)
     
}
\author{Stefan Theussl}
