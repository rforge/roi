## ROI plugin: CPLEX

.solve_MILP_via_cplex <-
function(x, control)
{
    ## Wrap into the common MIP CPLEX framework.
    x$objective <- list(Q = NULL, L = x$objective)
    .solve_MIP_via_cplex(x, control)
}

.solve_MIQP_via_cplex <-
function(x, control)
{
    ## Ensure that the coefficient matrix of the quadratic term is
    ## symmetric, as required by Rcplex.
    Q <- x$objective$Q
    ## <CHECK>
    ## Does Rcplex really support simple triplet matrix Q coefficients?
    ## If not, would need
    ##   x$objective$Q <- as.matrix((Q + t(Q)) / 2)
    ## instead:
    x$objective$Q <- (Q + t(Q)) / 2
    ## </CHECK>
    .solve_MIP_via_cplex(x, control)
}

.solve_MIP_via_cplex <-
function(x, control)
{
    ## Currently, no direct support for bounds.
    ## <FIXME>
    ## Should expand the given bounds and map into lb/ub arguments.
    if(!is.null(x$bounds))
        stop("Solver currently does not support variable bounds.")
    ## </FIXME>

    sense <- .as_Rcplex_sense(x$constraints$dir)

    types <- .expand_types(x$types, length(x$objective$L))

    mat <- x$constraints$mat
    if(is.simple_triplet_matrix(mat)) {
        ## Reorder indices as CPLEX needs a column major order
        ## representation i.e., column indices j have to be in ascending
        ## order.
        column_major_order <- order(mat$j)
        mat$i <- mat$i[column_major_order]
        mat$j <- mat$j[column_major_order]
        mat$v <- mat$v[column_major_order]
    } else {
        mat <- as.matrix(mat)
    }

    if(is.null(nos <- control$n)) nos <- 1L
    value_is_list_of_solutions <- !identical(as.integer(nos), 1L)

    out <-
        tryCatch(Rcplex::Rcplex(Qmat = x$objective$Q,
                                cvec = x$objective$L,
                                Amat = mat,
                                sense = sense,
                                bvec = x$constraints$rhs,
                                vtype = types,
                                objsense = if(x$maximum) "max" else "min",
                                control = list(trace = 0, round = 1),
                                n = nos
                                ),
                 error = identity)
    if(inherits(out, "error")) {
        ## Explicitly catch and rethrow CPLEX unavailability errors.
        msg <- conditionMessage(out)
        if(regexpr("Could not open CPLEX environment\\.", msg) > -1L)
           stop(msg, call. = FALSE)
        ## Currently, Rcplex signals problems via error() rather than
        ## returning a non-zero status.  Hence, we try catching these
        ## errors.  (Of course, these could also be real errors ...).
        solution <- rep(NA_real_, length(types))
        objval <- NA_real_
        status <- 2                     # or whatever ...
        names(status) <- msg            # should be of length one ...
        out <- .make_MIP_solution(solution, objval, status)
        if(value_is_list_of_solutions) out <- list(out)
    } else {
        out <- if(value_is_list_of_solutions)
            lapply(out, .canonicalize_solution_from_cplex, x)
        else
            .canonicalize_solution_from_cplex(out, x)
    }
    out
}

.canonicalize_solution_from_cplex <-
function(out, x)
{
    solution <- out$xopt
    ## For the time being ...
    ## Since Rcplex 0.1-4 integers are rounded (via control argument
    ## 'round' which we set accordingly when calling Rcplex()) but no
    ## new optimal solution based on these values is calculated.  Hence,
    ## we no longer round ourselves, but recompute objval.
    objval <- sum(solution * x$objective$L)
    if(!is.null(Q <- x$objective$Q))
        objval <- objval + .xtQx(Q, solution) / 2
    status <- out$status
    ## Simple db for "ok" status results:
    ok_status_db <-
        c("CPX_STAT_OPTIMAL" = 1L,      # (Simplex or barrier): optimal
                                        # solution is available
          "CPXMIP_OPTIMAL" = 101L,      # (MIP): optimal integer solution
                                        # has been found
          "CPXMIP_OPTIMAL_TOL" = 102L,  # (MIP): Optimal soluton with
                                        # the tolerance defined by epgap
                                        # or epagap has been found
          "CPXMIP_POPULATESOL_LIM" = 128L, # (MIP-MultSols): The limit on
                                        # mixed integer solutions
                                        # generated by populate has been
                                        # reached
          "CPXMIP_OPTIMAL_POPULATED" = 129L, # (MIP-MultSols): Populate
                                        # has completed the enumeration of
                                        # all solutions it could enumerate
          "CPXMIP_OPTIMAL_POPULATED_TOL" = 130L # (MIP-MultSols): similar
                                        # to 129L but additionally
                                        # objective value fits the
                                        # tolerance specified by paramaters
          )
    status <- ifelse(status %in% ok_status_db, 0, status)
    .make_MIP_solution(solution, objval, status)
}
