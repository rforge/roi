## objective.R

L_objective <- function( L ) {
  
}

Q_objective <- function( Q, L = NULL ) {
  
}

as.linear_objective <- function(x, ...)
  UseMethod("as.linear_objective")

as.linear_objective.numeric <- function(x)
  linear_objective(x)

linear_objective <- function(x){
  structure( list(L = as.numeric(x)), class = "linear_objective")
 }

make_objective <- function(L, Q, N, ...){
  structure( list(L = as.linear_objective(L), Q = as.quadratic_objective(Q), N = as.generic_objective(N)), class = c("objective") )
}

objective <- function(x, ...)
  UseMethod("objective")

objective.MILP <- function(x)
  x$objective


constraints <- function(x){
  
}


make_constraints <- function(L = NULL, Q = NULL, N = NULL, ...)
  structure( list(L = as.linear_constraints(L),
                  Q = as.quadratic_constraints(Q),
                  N = as.generic_constraint(N),
                  class = "constraints")
            )

terms <- function(x, ...){
  UseMethod("terms")
}

terms.constraints <- function(x){
  
}


MILP <-
function(objective, constraints, bounds = NULL, types = NULL,
         maximum = FALSE)
{
    ## Currently, 'constraints' always is a (not necessarily named) list
    ## with mat, dir and rhs, which really is the most general case of
    ## linear constraints we can think of.  Let us add names for now;
    ## eventually, there should be more sanity checking and maybe a
    ## creator for linear constraint objects.

    names(constraints) <- c("mat", "dir", "rhs")
    structure(list(objective = make_objective(L = objective),
                   constraints = make_constraints(L = constraints), 
                   bounds = bounds,
                   types = types,
                   maximum = maximum),
              class = "MILP")
}




constraints <- function(x, ...)
  UseMethod("constraints")

constraints.MILP <- function(x)
  x$constraints


## LP
list(objective = list(L = numeric()),
     constraints = list(L = list(mat = matrix(), dir = dir, rhs = numeric())),
     bounds = list(upper = list(i = integer(), v = set()), lower = list(i = integer(), v = set())),
     maximum = logical()
     )

## QP/QCP
list(objective = list(L = numeric(),
                      Q = matrix()),
     constraints = list(L = list(mat, dir, rhs),
                        Q = list(list(list(L = numeric(), Q = matrix())), dir, rhs)),
     bounds = list(upper = list(i = integer(), v = set()), lower = list(i = integer(), v = set())),
     maximum = logical()
     )

             
