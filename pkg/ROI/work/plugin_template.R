## ROI plugin: mysolver
## based on MySolver interface

## SOLVER METHODS

## we need for each problem class a separate solver method

.solve_PROBLEM_CLASS.mysolver <- function( x, control ) {
  ## if needed, add constraints made from variable bounds
  ##if( length(bounds(x)) )
  ##  constraints(x) <- rbind(constraints(x),
  ##                         .make_box_constraints_from_bounds(bounds(x),
  ##                                     dim(terms(objective(x))$Q)[1]) )

  ## solve the QP
  ## adjust arguments depending on problem class
  out <- .mysolver_solve_PROBLEM_CLASS(Q = terms(objective(x))$Q,
                                       L = terms(objective(x))$L,
                                       mat = constraints(x)$L,
                                       dir = constraints(x)$dir,
                                       rhs = constraints(x)$rhs,
                                       max = x$maximum)
  class(out) <- c(class(x), class(out))
  .canonicalize_solution(out, x)
}

.mysolver_solve_PROBLEM_CLASS <- function(Q, L, mat, dir, rhs, max) {
  ## here comes the glue code
  ## look at other plugins to get a feeling on what should be done here
}

## CANONICALIZER

## adjust list item names appropriately
.canonicalize_solution.mysolver <- function(out, x){
  solution <- out$MY_SOLVER_SOLUTION
  objval <- objective(x)(solution)
  status <- .canonicalize_status(out$MYSOLVER_STATUS, class(out)[1])
    .make_MIP_solution(solution, objval, status)
}

## STATUS CODES

.add_mysolver_status_codes <- function(){
  ## add all status codes generated by the solver to db

  ## Two examples are listed here:
  add_status_code_to_db("mysolver", 
                        0L,
                        "OPTIMAL",
                        "Solution is optimal",
                        0L
                        )
  add_status_code_to_db("mysolver", 
                        1L,
                        "NOT_OPTIMAL",
                        "No solution."
                        )  
  invisible(TRUE)
}

